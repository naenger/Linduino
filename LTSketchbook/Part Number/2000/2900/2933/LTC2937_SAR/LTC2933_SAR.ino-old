/*!
Linear Technology DC1633B Demonstration Board.
LTC2933: Programable Hex Voltage Supervisor with EEPROM

@verbatim

  Setup:
   Power the demo board through the Linduino connector (12-pin adapter required).
     - the DC2294A-1 shield provides the necessary 12-pin connector
   Set the Linduino terminal baud rate to 115200 and select the newline terminator.

   NOTE: GPI2 is configured as a MARGIN pin. It will defeat the SAR algorithm if it is asserted.

@endverbatim

http://www.linear.com/product/LTC2933
http://www.linear.com/demo/DC1633B

REVISION HISTORY
$Revision: $
$Date: $

Copyright (c) 2015, Linear Technology Corp.(LTC)
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of Linear Technology Corp.

The Linear Technology Linduino is not affiliated with the official Arduino team.
However, the Linduino is only possible because of the Arduino team's commitment
to the open-source community.  Please, visit http://www.arduino.cc and
http://store.arduino.cc , and consider a purchase that will help fund their
ongoing work.

No animals were harmed in the making of this product.
*/

/*! @file
    @ingroup LTC2933
*/

#include <Arduino.h>
#include <stdint.h>
#include "Linduino.h"
#include "UserInterface.h"
#include "LT_I2CBus.h"
#include "LT_SMBusNoPec.h"
#include "LTC2933.h"


// LTC2637 DAC on the DC1633B board
#define DC1633_DAC_ADDRESS 0x22 //pin-strapped address for DAC

//LTC2933 I2C address on the board (selectable by a jumper)
#define LTC2933_I2C_ADDRESS LTC2933_I2C_GLOBAL_ADDRESS

// Global variables
static uint8_t ltc2933_i2c_address;
static uint8_t dc1633_dac_address;
static LT_SMBus *smbus = new LT_SMBusNoPec();

//! Initialize Linduino
void setup()
{
  Serial.begin(115200);         //! Initialize the serial port to the PC
  print_title();
  ltc2933_i2c_address = LTC2933_I2C_ADDRESS;
  dc1633_dac_address = DC1633_DAC_ADDRESS;
  print_prompt();
}


//! Repeats Linduino loop
void loop()
{
  uint8_t user_command;
  uint16_t res;
  float dac_voltage;
  
  if (Serial.available())                          //! Checks for user input
    {
      user_command = read_int();                     //! Reads the user command
      if (user_command != 'm')
	Serial.println(user_command);
      
      switch (user_command)                          //! Prints the appropriate submenu
	{
	case 0:
	  //! write the LTC2933 CLEAR_ALERT
	  ltc2933_clear_alertb(ltc2933_i2c_address);
	  break;
	case 1:
	  //! write to the LTC2637 DACs on the DC1633 board to interesting voltages
	  //!  other than the 2.0v DAC defaults
	  dc1633_write_dac_voltage(dc1633_dac_address, 0, 3.3);
	  dc1633_write_dac_voltage(dc1633_dac_address, 1, 2.5);
	  dc1633_write_dac_voltage(dc1633_dac_address, 2, 1.8);
	  dc1633_write_dac_voltage(dc1633_dac_address, 3, 1.5);
	  dc1633_write_dac_voltage(dc1633_dac_address, 4, 1.2);
	  dc1633_write_dac_voltage(dc1633_dac_address, 5, 1.0);
	  //! write all LTC2933 registers with corresponding interesting voltage settings
	  ltc2933_demo_board_demo_thresholds(ltc2933_i2c_address);
	  break;
	case 2:
	  // perform a single SAR search
	  LTC2933_SAR_search(ltc2933_i2c_address, 2);
	  break;
	case 3:
	  // perform a single SAR search
	  LTC2933_SAR_search(ltc2933_i2c_address, 3);
	  break;
	case 4:
	  // perform a single SAR search
	  LTC2933_SAR_search(ltc2933_i2c_address, 4);
	  break;
	case 5:
	  // perform a single SAR search
	  LTC2933_SAR_search(ltc2933_i2c_address, 5);
	  break;
	case 6:
	  // perform a single SAR search
	  LTC2933_SAR_search(ltc2933_i2c_address, 6);
	  break;
	case 7:
	  //! adjust the CH6 DAC voltage
	  Serial.println(F("Enter DAC voltage between 0.0V and 4.095V:"));
	  dac_voltage = read_float();
	  dc1633_write_dac_voltage(dc1633_dac_address, 5, dac_voltage);
	  break;
	default:
	  Serial.println(F("Incorrect Option"));
	  break;
	}
      Serial.println(F("\n\n"));
      print_prompt();
    }
}



///////////////////////////////////////////////////////////////////////////////////////////////
// Function Definitions

//! Prints the title block when program first starts.
void print_title()
{
  Serial.print(F("\n*****************************************************************\n"));
  Serial.print(F("* DC1633B Demonstration Program                                 *\n"));
  Serial.print(F("*                                                               *\n"));
  Serial.print(F("* This program demonstrates how to implement a simple SAR ADC   *\n"));
  Serial.print(F("* using one channel of the LTC2937 on the DC1633B demo board.   *\n"));
  Serial.print(F("*                                                               *\n"));
  Serial.print(F("* Set the baud rate to 115200 and select the newline terminator.*\n"));
  Serial.print(F("*                                                               *\n"));
  Serial.print(F("*****************************************************************\n"));
}

//! Prints main menu.
void print_prompt()
{
  Serial.print(F("  0-Clear LTC2933 ALERTB\n"));
  Serial.print(F("  1-Write LTC2933 registers with default settings.\n"));
  Serial.print(F("  2-Take CH2 off-line and perform a SAR search for the pin voltage.\n"));
  Serial.print(F("  3-Take CH3 off-line and perform a SAR search for the pin voltage.\n"));
  Serial.print(F("  4-Take CH4 off-line and perform a SAR search for the pin voltage.\n"));
  Serial.print(F("  5-Take CH5 off-line and perform a SAR search for the pin voltage.\n"));
  Serial.print(F("  6-Take CH6 off-line and perform a SAR search for the pin voltage.\n"));
  Serial.print(F("  7-Set CHn DAC voltage manually\n"));
  //  Serial.print(F("  4-Set DAC voltages on Vn pins to interesting values\n"));
  //  Serial.print(F("  5-Change LTC2933 voltage thresholds to match interesting DAC voltages\n"));
  //  Serial.print(F("  6-Set DAC voltages on Vn pins to +20% high values\n"));
  //  Serial.print(F("  8-Bus Probe\n"));
  Serial.print(F("\nEnter a command:"));
}



//! Return 1 if the LTC2933 is write-protected
//  0 otherwise
int ltc2933_is_write_protected(uint8_t ltc2933_i2c_address)
{
  uint16_t res;

  res = smbus->readWord(ltc2933_i2c_address, LTC2933_STATUS_WORD);

  //b[0] is the write-protect bit
  return ((res&0x0001) == 0x0001) ? 1 : 0;
}


//! Load different voltage threshold settings into RAM
void ltc2933_demo_board_demo_thresholds(uint8_t ltc2933_i2c_address)
{
  if (ltc2933_is_write_protected(ltc2933_i2c_address) != 1)
  {
    smbus->writeWord(ltc2933_i2c_address, LTC2933_WRITE_PROTECT, 0xAAA8);
    smbus->writeWord(ltc2933_i2c_address, LTC2933_GPI_CONFIG, 0x1040); // GPI2=MARG, not mapped; GPI1=MR, clear history, not mapped
    smbus->writeWord(ltc2933_i2c_address, LTC2933_GPIO1_CONFIG, 0x002E);
    smbus->writeWord(ltc2933_i2c_address, LTC2933_GPIO2_3_CONFIG, 0x2E07);
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V1_THR, 0x412D); // ov = 5.5, uv = 4.5
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V2_THR, 0x554B); // ov = 2.6, uv = 2.4
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V3_THR, 0x917D); // ov = 1.9, uv = 1.7
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V4_THR, 0x735F); // ov = 1.6, uv = 1.4
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V5_THR, 0x5541); // ov = 1.3, uv = 1.1
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V6_THR, 0x3C32); // ov = 1.05, uv = 0.95
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V1_CONFIG, 0x009C); // high range
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V2_CONFIG, 0x009C); // medium range
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V3_CONFIG, 0x019C); // low range
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V4_CONFIG, 0x019C); // low range
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V5_CONFIG, 0x019C); // low range
    smbus->writeWord(ltc2933_i2c_address, LTC2933_V6_CONFIG, 0x019C); // low range
  }
  else
  {
    // error, LTC2933 is write-protected
    Serial.println(F("\nERROR: LTC2933 is write-protected. Cannot write to registers"));
  }
}

//! Clear ALERTB
void ltc2933_clear_alertb(uint8_t ltc2933_i2c_address)
{
  smbus->writeWord(ltc2933_i2c_address, LTC2933_CLEAR_HISTORY, 0x0000);
}


//! program the DAC on the DC1633B demo board to a voltage
//  refer to the LTC2637 datasheet
void dc1633_write_dac_voltage(uint8_t dac_address, int channel, float voltage)
{
  uint8_t *data = (uint8_t *)malloc(3*sizeof(uint8_t));
  uint8_t cmd, ch_addr;
  uint16_t v_data;
  float v;

  // pack the data bytes with the necessary bits
  // channel numbers 0 - 7 correspond to letters A - H in the datasheet
  if ((channel < 8) && (channel >= 0))
  {
    ch_addr = (uint8_t)channel;
  }
  else
  {
    //address all channels
    ch_addr = 0x0F;
  }
  cmd = 0x30; // the write to and update command
  data[0] = cmd | ch_addr;

  if ((voltage > 0) && (voltage < 4.096))
  {
    v = (voltage/4.096);
    v_data = (uint16_t)(v*4096);
  }
  else
  {
    Serial.println(F("\nERROR: Voltage out of DAC range"));
  }
  data[1] = (uint8_t)(v_data >> 4); // most significant bits
  data[2] = (uint8_t)(v_data << 4); // least significant bits

  //write the command and data to the DAC
  LT_Wire.beginTransmission(dac_address);
  LT_Wire.expectToWrite((uint16_t) 3);
  //  LT_Wire.write(command);
  LT_Wire.write(data[0]);
  LT_Wire.write(data[1]);
  LT_Wire.write(data[2]);
  LT_Wire.endTransmission(1);

  free(data);
  return;

}

//! Perform a SAR search for the voltage on channel <ch_num>
uint8_t LTC2933_SAR_search(uint8_t ltc2933_i2c_address, int ch_num)
{
  uint16_t save_vn_thr = 0x0000; //save the vn register state during the SAR search
  uint16_t save_vn_config = 0x0000; //save the vn register state during the SAR search
  uint16_t mod_vn_thr = 0x0000; //modified vn register state during the SAR search
  uint16_t mod_vn_config = 0x0000; //modified vn register state during the SAR search
  uint16_t ltc2933_status, ltc2933_status_mask;
  
  //  int bit = 7; // counter
  uint16_t sar = 0x8000; // sar register
  
  static int settling_time = 10; // number of milliseconds for settling between SAR steps

  if ((ch_num > 1) && (ch_num <= 6)) {
    // CH1 is different from the others, so it doesn't play nicely with this function
    save_vn_thr = smbus->readWord(ltc2933_i2c_address, (LTC2933_V1_THR + ch_num-1));
    save_vn_config = smbus->readWord(ltc2933_i2c_address, (LTC2933_V1_CONFIG + ch_num-1));
    
    // modify CH6, leave the others alone
    mod_vn_config = (save_vn_config & 0xFF00) | 0x0080; // use only the HI comparator
    
    mod_vn_thr = 0x8000;
    sar = 0x8000;

    Serial.print(F("CONVERTING CHANNEL "));
    Serial.println(ch_num, DEC);
    switch (ch_num)
      {
      case 1 :
	ltc2933_status_mask = 0x0004;
	break;
      case 2 :
	ltc2933_status_mask = 0x0010;
	break;
      case 3 :
	ltc2933_status_mask = 0x0040;
	break;
      case 4 :
	ltc2933_status_mask = 0x0100;
	break;
      case 5 :
	ltc2933_status_mask = 0x0400;
	break;
      case 6 :
	ltc2933_status_mask = 0x1000;
	break;
      default :
	ltc2933_status_mask = 0x0000;
	break;
      }
	
	  
    //set the config reg
    // leave the RANGE unchanged, but remove the channel from GPIO mapping
    smbus->writeWord(ltc2933_i2c_address, (LTC2933_V1_CONFIG + ch_num-1), mod_vn_config);
    
    
    while(sar > 0x00FF) {
      //set the threshold
      smbus->writeWord(ltc2933_i2c_address, (LTC2933_V1_THR + ch_num-1), mod_vn_thr);
      
      //wait for settling
      delay(settling_time);
      
      //read the status register, mask for the Vn_HI_FAULT bit
      ltc2933_status = (ltc2933_status_mask & smbus->readWord(ltc2933_i2c_address, LTC2933_STATUS_WORD));
      
      //interpret the result
      // if 1, then the voltage is above the threshold, if 0 then below
      if(ltc2933_status != 0x0000) {
	// keep the bit set and move-on to the next LSB
	sar = sar >> 1; // shift right
	mod_vn_thr = mod_vn_thr | sar;
	// Serial.println(F("HIGHER "));
      }
      else {
	// clear the bit and move-on to the next LSB
	mod_vn_thr = (mod_vn_thr & (~sar));
	sar = sar >> 1; // shift right
	mod_vn_thr = mod_vn_thr | sar;
	//  Serial.println(F("LOWER "));
      }
      // Serial.println(F("HIT RETURN TO CONTINUE..."));
      // read_int();
    }
  
    // upon exiting the loop the mod_vn_thr register upper byte contains the
    //  DAC threshold nearest to the pin voltage, but not above it
    mod_vn_thr = mod_vn_thr>>8;
    Serial.print(F("SAR RESULT (HEX): "));
    Serial.println(mod_vn_thr, HEX);
    Serial.print(F("SAR RESULT (VOLTS): "));
    // convert register value to volts, depending upon threshold range setting
    // NOTE: this conversion is for CH2 - CH6, NOT CH1
    switch (save_vn_config & 0x0300)
      {
      case 0x0300 :
      case 0x0200 :
	// precision range
	Serial.println((0.18+(0.004 * int(mod_vn_thr))), DEC);
	break;
      case 0x0100 :
	// low range
	Serial.println((0.45+(0.01 * int(mod_vn_thr))), DEC);
	break;
      case 0x0000 :
	// medium range
	Serial.println((0.90+(0.02 * int(mod_vn_thr))), DEC);
	break;
      default :
	Serial.println(F("ERROR: BOGUS RANGE CODE IN Vn_CONFIG!"));
	break; 
	// NOTE: high range is only used in CH1
	// high range
	//  Serial.println((2.25+(0.05 * int(mod_vn_thr))), DEC);
      }
    // NOTE: restoring the register settings is a bit touchy
    // if you try to change the range or threshold settings from what they were
    //  before the SAR algotithm you can cause a fault as the thresholds change
    smbus->writeWord(ltc2933_i2c_address, (LTC2933_V1_THR + ch_num-1), save_vn_thr); // restore Vn config
    smbus->writeWord(ltc2933_i2c_address, (LTC2933_V1_CONFIG + ch_num-1), save_vn_config); // restore Vn config
    
    return (uint8_t(mod_vn_thr));
  }
  else {
    // invalid channel number
    Serial.println(F("ERROR: INVALID CHANNEL NUMBER!"));
    return (0);
  }
}
